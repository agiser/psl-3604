//----------------------------------------------------------------------------

//Модуль программной реализации шины I2C

//----------------------- Используемые ресурсы: ------------------------------

//Используются пины SCL (PB8) и SDA (PB9).
//Для формирования таймингов шины используется таймер TIM16.

//----------------------------------------------------------------------------

#include "main.h"
#include "systimer.h"
#include "i2csw.h"

//----------------------------- Константы: -----------------------------------

#define I2C_CLK    100 //частота шины I2C, кГц

#define I2C_DELAY (APB2_CLOCK / 1000 / I2C_CLK / 2 - 18)

//----------------------------------------------------------------------------
//----------------------------- Класс TI2Csw: --------------------------------
//----------------------------------------------------------------------------

//----------------------------- Инициализация: -------------------------------

TGpio<PORTB, PIN8> TI2Csw::Pin_SCL; 
TGpio<PORTB, PIN9> TI2Csw::Pin_SDA;

void TI2Csw::Init(void)
{
  Pin_SCL.Init(OUT_OD_2M, OUT_HI);
  Pin_SDA.Init(OUT_OD_2M, OUT_HI);

  RCC->APB2ENR |= RCC_APB2ENR_TIM16EN; //включение тактирования TIM16
  TIM16->PSC = 0;                      //загрузка прескалера
  TIM16->ARR = 0xFFFF;                 //период
  TIM16->CR1 = TIM_CR1_CEN;            //разрешение таймера
  
  Free(); //сброс I2C
  Stop();
}

//------------------------ Освобождение шины I2C: ----------------------------

void TI2Csw::Free(void)
{
  for(char i = 0; i < 9; i++)
  {
    if(Pin_SDA) break;
    Pin_SCL = 0;
    BitDelay();
    Pin_SCL = 1;
    BitDelay();
  }
}

//------------------- Генерация условия "СТАРТ" на I2C: ----------------------

void TI2Csw::Start(void)
{
  Pin_SDA = 0;
  BitDelay();
}

//------------------------- Запись байта по I2C: -----------------------------

bool TI2Csw::Write(char data)
{
  bool ack = 0;
  for(char i = 0; i < 8; i++)
  {
    Pin_SCL = 0;
    if(data & 0x80)
      Pin_SDA = 1;
        else Pin_SDA = 0;
    data <<= 1;    
    BitDelay();
    Pin_SCL = 1;
    BitDelay();
  }
  Pin_SCL = 0;
  Pin_SDA = 1;
  BitDelay();
  Pin_SCL = 1;
  BitDelay();
  ack = !Pin_SDA;
  BitDelay();
  return(ack);
}

//------------------------- Чтение байта по I2C: -----------------------------

char TI2Csw::Read(bool ack)
{
  char data;
  for(char i = 0; i < 8; i++)
  {
    Pin_SCL = 0;
    Pin_SDA = 1;
    BitDelay();
    Pin_SCL = 1;
    BitDelay();
    data = data << 1;
    if(Pin_SDA) data |= 0x01;
  }
  Pin_SCL = 0;
  Pin_SDA = !ack;
  BitDelay();
  Pin_SCL = 1;
  BitDelay();
  return(data);
}

//------------------- Генерация условия "СТОП" на I2C: -----------------------

void TI2Csw::Stop(void)
{
  Pin_SCL = 0;
  Pin_SDA = 0;
  BitDelay();
  Pin_SCL = 1;
  BitDelay();
  Pin_SDA = 1;
  BitDelay();
}

//---------------------- Задержка 1/2 периода I2C: ---------------------------

void TI2Csw::BitDelay(void)
{
  TIM16->CNT = 0;
  while(TIM16->CNT < I2C_DELAY);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
